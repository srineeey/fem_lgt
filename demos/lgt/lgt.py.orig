#from ngsolve import CF, Trace, Conj, cos, sin, InnerProduct, Cross, GridFunction, specialcf, IfPos
from ngsolve import *
from ngsolve.webgui import Draw

#from ngsolve.meshes import *

import sys
import time

sys.path.insert(1, '../quaternion/')

from quaternion_cf import *


import numpy as np

def get_gfor(mesh):
    fesHd = HDiv(mesh, order=0)
    gfor = GridFunction(fesHd)
    #gfor = GridFunction(HDiv(mesh, order=0))
    gfor.vec.data[:] = 1.
    return gfor

def get_gfUglob(gfU, fesU):
    n = specialcf.normal(gfU.space.mesh.dim)
    gfor = get_gfor(fesU.mesh)
    return IfPos(gfor*n, gfU, qconjCF(gfU))

def draw_orientededges(e_ors, mesh):
    fesedge = HDiv(mesh, order=1)
    
    gfedge = GridFunction(fesedge)
    
    
    gfedge.vec.data[:] = 0.
    for e_num, e_or in e_ors:
        #print(e_num, e_or)
        #gfedge.vec.data[:] = 0.
        #gfedge.vec.data[e_num] = 1.
        gfedge.vec.data[e_num] = 2.*float(int(e_or)) - 1.
        #Draw(gfedge, vectors=True)
    
    Draw(gfedge, vectors=True)



def check_facet_vorb(meshvars):
    # checking FacetVorb
    mesh = meshvars.GetMeshAccess()
    meshvars.EvaluateFacetVorb()
    feshd = HDiv(mesh, order=1)
    gfhd = GridFunction(feshd)
    scene = Draw(gfhd, mesh)
    for i in range(mesh.ne):
    #for i in []:
        print ("\r", f"edge:{i} is in VOL: {meshvars.FacetVorb(i)}", end="")
        gfhd.vec.data[:] = 0.
        gfhd.vec.data[i] = 1.
        
        scene.Redraw()
        time.sleep(1)

<<<<<<< HEAD
def check_vertex_vorb(meshvars):
    # checking FacetVorb
    mesh = meshvars.GetMeshAccess()
    meshvars.EvaluateVertexVorb()
    fesh1 = H1(mesh, order=1)
    gfh1 = GridFunction(fesh1)
    scene = Draw(gfh1, mesh)
    for i in range(mesh.nv):
    #for i in []:
        print ("\r", f"vertex:{i} is in VOL: {meshvars.VertexVorb(i)}", end="")
        gfh1.vec.data[:] = 0.
        gfh1.vec.data[i] = 1.
        
        scene.Redraw()
        time.sleep(1)
=======
        
# THE VISUALIZATION OF THIS FUNCTION DEMONSTRATES THE FOLLOWING:
# THE GLOBAL ORIENTATION OF THEHDIV LOWEST ORDER
# IS GENERATED BY LEFT TILTING EDGEVECTORS = VERTEX1 (HIGHER NR) - VERTEX0 (LOWER NR)
# at least for quads
def check_ellink_orientation(meshvars):
    mesh = meshvars.GetMeshAccess()
    feshd = HDiv(mesh, order=1)
    gfhd = GridFunction(feshd)
    scene = Draw(gfhd, mesh)
    
    for el in mesh.Elements():
        #print(el.nr)
        gfhd.vec.data[:] = 0.
        for facet in el.facets:
            #print(f"facet.nr: {facet.nr}")
            eor = meshvars.ElLinkOrientation(facet.nr, el.nr)
            #print ("\r", f"el={el.nr} e={facet.nr} element orientation:{eor}", end="")
            #gfhd.vec.data[:] = 0.
            if eor:
                gfhd.vec.data[facet.nr] = 1.
            else:
                gfhd.vec.data[facet.nr] = -1.
                #gfhd.vec.data[facet.nr] = 1.

        scene.Redraw()
        time.sleep(1)
        #input()
        
>>>>>>> b769ef8a1fd3f882d25e67ffcc2ab0b2cdc966cf



def draw_tbone_weights(meshvars):
    # checking weights of temporal bones
    mesh = meshvars.GetMeshAccess()
    fesh1 = H1(mesh, order=1)
    gfh1 = GridFunction(fesh1)
    scene = Draw(gfh1, mesh)
    for i in range(mesh.nv):
    #for i in []:
        print ("\r", f"vertex={i} weight:{meshvars.GettBoneWeight(i)}", end="")
        gfh1.vec.data[:] = 0.
        gfh1.vec.data[i] = 1.
        
        scene.Redraw()
        time.sleep(1)

def draw_bone_weights(meshvars):
    meshvars.EvaluateFacetVorb()
    mesh = meshvars.GetMeshAccess()
    feshd = HDiv(mesh, order=1)
    gfhd = GridFunction(feshd)
    scene = Draw(gfhd, mesh)
    for i in range(mesh.nedge):
    #for i in []:
        print ("\r", f"e={i} weight:{meshvars.GetBoneWeight(i)}", end="")
        gfhd.vec.data[:] = 0.
        gfhd.vec.data[i] = 1.
        
        scene.Redraw()
        time.sleep(1)


"""
LGT functions for link time evolution
using python functions
"""


# TODO: orientation and order!
def get_vedges(v, mesh):
    #print (v, v.point, v.edges)
    vedges = []
    for edge_id in v.edges:
        #print(edge_id)
        edge = mesh[edge_id]
        if v in edge.vertices:
            vedges.append(edge)
    #print(vedges)
    return vedges


# returns array of edges [(edge_id, orientation), ...] 
# orientation:
# 1 means: ok
# 0 means: needs to be flipped
#TODO: periodic are being BC ignored!
def get_oriented_vedges_tan(v, mesh):
    
    # coordinates of the point on the mesh
    pv = np.array(mesh[v].point)
    
    edge_angles = []
    for edge_id in v.edges:
        edge = mesh[edge_id]
        
        #print(f"edge vertices of {edge}")
        #print(edge.vertices)
        if v in edge.vertices:
            #print(f"found vertex {v}")
            
            # index of vertex vi
            # either 0 or 1
            vi = edge.vertices.index(v)
            
            # the other vertex belonging to the edge
            # has opposite index
            p2 = np.array(mesh[edge.vertices[int(not bool(vi))]].point)
            edgevec = p2 - pv
            edgevec = edgevec/np.linalg.norm(edgevec)
            
            # TODO: correct and consistent angle
            edge_angle = np.arctan2(edgevec[1], edgevec[0])
            # the second entry reflects the orientation of the link going around the vertex in a loop
            # this can be different than the global orientation
            #print((edge.nr, int(not bool(vi)), edge_angle))
            edge_angles.append((edge.nr, int(not bool(vi)), edge_angle))
            
            
    edge_angles = np.array(edge_angles, dtype=[("edge_id", int), ("orientation", int), ("angle", float)])
    #print("accumulated vertice edges")
    #print(edge_angles)
    
    # sort edges with respect to angles
    ordered_edge_angles = np.sort(edge_angles, order="angle")
    #print("ordered vertice edges")
    #print(ordered_edge_angles)
    
    #TODO: more efficient slicing
    ordered_edge_angles = np.array([ [ordered_edge_angles[k][0], ordered_edge_angles[k][1]] for k in range(len(ordered_edge_angles)) ])
                                   
    return ordered_edge_angles
    
    
def get_qlink(gfU, facet):
    qU = np.array([gfU.components[i].vec[facet.nr] for i in range(gfU.dim)])
    return qU
    

# get temporal wilson loops (polyakov loops)
# in temporal gauge
# therefore only 2 spatial links are required instead of 2+2
def get_polyakov_loop(gfU, oldgfU, bone, mesh, forward=True):
    
    #print(f"bone: {bone}")
    
    qU = np.array([gfU.components[i].vec[bone.nr] for i in range(gfU.dim)])
    qoldU = np.array([oldgfU.components[i].vec[bone.nr] for i in range(gfU.dim)])
    
    if forward == True:
        return qmul(qU, qconj(qoldU))
    else:
        return qmul(qoldU, qconj(qU))
    
# get spatial wilson loop
def get_qwilson_loop(gfU, bone, mesh, start_edge=None, last_edge=None, vedges_list=None):
    
    #print(f"bone: {bone}")
    
    if vedges_list==None:
        vedges_ors = get_oriented_vedges_tan(bone, mesh)
    else:
        vedges_ors = vedges_list[bone.nr]
    #print(f"vedges_ors: {vedges_ors}")
    
    #TODO: permute more efficiently
    if start_edge != None:
        i_start = (list(vedges_ors[:,0])).index(start_edge.nr)
        vedges_ors = np.array( [*vedges_ors[i_start:], *vedges_ors[:i_start]] )
        #print("cyclically permuted edges")
        
    if last_edge != None:
        i_last = (list(vedges_ors[:,0])).index(last_edge.nr)
        if i_last != (len(list(vedges_ors[:,0])) - 1):
            vedges_ors = np.array( [*vedges_ors[i_last+1:], *vedges_ors[:i_last+1]] )
            #print("cyclically permuted edges")
            
        
    #print(f"vedges_ors: {vedges_ors}")
        
    
    #initialize wilson loop with identity
    qwilson_loop = np.array([1,0,0,0])
    
    #TODO: LGT convention?
    #print("calculating wilson loop")
    for vedge, orientation in vedges_ors:
        #print(f"vedge: {vedge}")
        #print(f"orientation {orientation}")
        qU = np.array([gfU.components[i].vec[vedge] for i in range(gfU.dim)])
        if orientation != 1:
            qU = qconj(qU)
        
        #print("Multiplying")
        #print(qU)
        #print("on top of")
        #print(qwilson_loop)
        #TODO: LGT convention?
        #qwilson_loop = qmul(qU, qwilson_loop)
        qwilson_loop = qmul(qwilson_loop, qU)
        #print("to get")
        #print(qwilson_loop)
        #print("\n")
        
        #print(np.linalg.norm(qwilson_loop))
        if np.abs(np.linalg.norm(qwilson_loop) - 1.0) > 10**(-10):
            raise ValueError(f"norm of q = {np.linalg.norm(qwilson_loop)}, and not 1")
     
    #print("returning wilson loop")
    #print(qwilson_loop)
    return qwilson_loop


# calculate the curvature represented by wilson loops around bones
# save them in a function gfW for visualization purposes
def calc_gfW(gfU, gfW, mesh):
    
    for v in mesh.vertices:
        #print(f"vertex: {v}")
        qw = get_qwilson_loop(gfU, v, mesh)
        for k in range(4):
            (gfW.components[k]).vec.data[v.nr] = qw[k]
        
    return gfW


#TODO: Not working atm
def calc_lnwilson_action(gfW, gfS):
    
    lnW_CF = qlogCF(gfW)
    # Taking the trace kills pauli matrices
    # i.e. the imaginary part of quaternions
    # factor N_C=2 because of 2 colors
    SCF = 2*(qmulCF(lnW_CF, qconjCF(lnW_CF)))[0]
    gfS = gfS.Set(SCF)
    
# This is the classical wilson action
# without mass matrix weights
def calc_wilson_action(gfW, gfS):
    su2gfW = su2mat_from_q(gfW)
    lnW_CF = CF((1,0,0,1)).Reshape((2,2)) - su2gfW
    # Taking the trace kills pauli matrices
    SCF = (Trace( lnW_CF * (Conj(lnW_CF).Reshape((2,2)).trans) )).real
    gfS = gfS.Set(SCF, dual=True)


    
    
    
    
def py_timestep(gfU, newgfU, oldgfU, mesh, v_weights, e_weights, dt, vedges_list=None):

    #iterate over all edges
    for e in mesh.edges:
        #print(e)
        # TODO
        # evaluate the new links vector part based on the old ones (in the edge-patch)
        # caution: correct orientation for updates
        # reconstruct new wilson loop (0-element) form vector part
        # multiply conjugated old link to obtain new link

        #edge = mesh.edges[edge]
        
        # get vertices hanging at edge
        # 2 vertices in 2D
        v0, v1 = e.vertices
        v0 = mesh.vertices[v0.nr]
        v1 = mesh.vertices[v1.nr]
        #print(v0)
        #print(v1)

        # variable to store present gauge link at edge
        qU = np.array([gfU.components[i].vec[e.nr] for i in range(0,4)])
        
        # there are two spatial loops for each edge
        # with opposite orientations
        if vedges_list == None:
            W_v0 = get_qwilson_loop(gfU, v0, mesh, start_edge=e)
            W_v1 = get_qwilson_loop(gfU, v1, mesh, last_edge=e)
        else:
            W_v0 = get_qwilson_loop(gfU, v0, mesh, start_edge=e, vedges_list=vedges_list)
            W_v1 = get_qwilson_loop(gfU, v1, mesh, last_edge=e, vedges_list=vedges_list)
        
        # one old temporal loop for each edge
        oldW_e = get_polyakov_loop(gfU, oldgfU, e, mesh, forward=True)

        #TODO: check signs and orientation
        #TODO: check mass matrix and dt factors
        #mass matrix update
        # factor of 2 to match with trace operation
        newW_evec = v_weights[v0.nr]*vec_from_q(W_v0) - v_weights[v1.nr]*vec_from_q(W_v1)
        #newW_evec = -2.*v_weights[v0.nr]*vec_from_q(W_v0) - v_weights[v1.nr]*vec_from_q(W_v1)
        #TODO: dt factor?
        newW_evec = dt*newW_evec
        #newW_evec = newW_evec/dt
        newW_evec += e_weights[e.nr]*vec_from_q(oldW_e)
        #newW_evec += -2.*e_weights[e.nr]*vec_from_q(oldW_e)
        newW_evec = (-1./e_weights[e.nr])*newW_evec
        
        #print("with norm")
        #print(np.linalg.norm(newW_evec))
        #print(vec_from_q(oldW_e))
        
        #print("with norm")
        #print(newW_evec.dot(newW_evec))
        
        if np.linalg.norm(newW_evec) > 1. :
            raise ValueError(f"update would lead to norm {np.linalg.norm(newW_evec)}")

        newW_e = np.array([np.sqrt(1 - newW_evec.dot(newW_evec)), *newW_evec])

        #print("\n")
        #print("updated")
        #print(old_qU)
        #print("to")
        #print(new_qU)
        
        #TODO: multiply qU and newW_e
        
        #newqU = qmul(qconj(newW_e), qU)
        newqU = qmul(qconj(newW_e), qU)

        for i in range(0,4):
            newgfU.components[i].vec.data[e.nr] = newqU[i]
        #print(np.linalg.norm(new_qU))



"""Gauge and Current Functions"""

# TODO: LGT CONVENTION?

# colors transform under the adjoint action
def rotate_color(c, g):
    
        return vec_from_q(qmulCF(qmulCF(qconjCF(g), q_from_vecCF(c)), g))

# CAREFUL: LGT CONVENTION!
def ptransport_color(f, gfUglob, forward=True):
    if forward == True:
        return rotate_color(f, gfUglob)
        #return vec_from_q(qmulCF(qmulCF(gfUglob, q_from_vecCF(f)), qconjCF(gfUglob)))
    elif forward == False:
        return rotate_color(f, qconjCF(gfUglob))
        #return vec_from_q(qmulCF(qmulCF(qconjCF(gfUglob), q_from_vecCF(f)), gfUglob))
    

# CAREFUL: LGT CONVENTION!
# in the continum one would have gl * U * gr^{-1}
# but different here because of LGT convention
def transform_link(gl,U,gr,forward=True):
    if forward == True:
        return qmulCF( qmulCF(qconjCF(gl),U), gr )
    if forward == False:
        return qmulCF( qmulCF(qconjCF(gr),U), gl )

# set link to a fixed value
def set_gfU_link_q(gfU, enum, q):

    for i in range(4):
        gfU.components[i].vec.data[enum] = q[i]
        

# Set all link values constant
def set_gfU_const(gfU, qtheta=0., theta=0., phi=0., glob_or=True):

    #identity
    gfU.components[0].vec[:] = 1
    gfU.components[1].vec.data[:] = 0
    gfU.components[2].vec.data[:] = 0
    gfU.components[3].vec.data[:] = 0

    #theta = 0.
    #phi = 0.
    n = axis(theta, phi)
    if glob_or == True:
        q = get_rotq(qtheta, n)
    elif glob_or == False:
        q = get_rotq(-1.*qtheta, n)
    
    #set_gfU_link_q(gfU, , q)
    for i in range(4):
        gfU.components[i].vec.data[:] = q[i]
        
    #return gfU



    
# set single link
def set_gfU_link(gfU, enum, qtheta=0., theta=0., phi=0., glob_or=True):

    #set_gfU_const(gfU, 0., 0., 0.)
    
    #enum = 220
    #theta = 0.
    #phi = 0.
    n = axis(theta, phi)

    #qtheta = 0.25*pi
    if glob_or == True:
        q = get_rotq(qtheta, n)
    elif glob_or == False:
        q = get_rotq(-1.*qtheta, n)

    set_gfU_link_q(gfU, enum, q)
    #for i in range(4):
    #    gfU.components[i].vec.data[enum] = q[i]
    
    #return gfU

        
# set multiple links
def set_gfU_links(gfU, enums, qthetas, thetas, phis, glob_ors):
    
    for i in range(len(enums)):
        #print(f"i:{i}")
        set_gfU_link(gfU, enums[i], qthetas[i], thetas[i], phis[i], glob_ors[i])
        
        

# gauge all links gfU with gauge transformation L2 GridFunction gfg
def gauge_gfU(gfU, gfg, fesU):
    
#     for el_num in range(mesh.ne):
#         q_g = [gfg.components[i].vec.data[el_num] for i in range(4)]    
#         gauge_gfU_q_El(gfU, el_num, q=q_g)

    n = specialcf.normal(fesU.mesh.dim)
    gfor = get_gfor(fesU.mesh)
    #print(type(gfor))
    #print(type(n))

    # gfUglob = IfPos(gfor*n, gfU, qconjCF(gfU))
    # gauged_gfU_CF = qmulCF( qmulCF(qconjCF(gfg),gfU), gfg.Other() )

    # whether the link points out of or into the element
    # is irrelevant for this purpose
    # therefore gfUglob does not have to be used

    # TODO: LGT convention
    #gauged_gfU_CF = IfPos(gfor*n, qmulCF( qmulCF(qconjCF(gfg),gfU), gfg.Other() ), qmulCF( qmulCF(gfg.Other(),gfU), qconjCF(gfg) ) )
    
    #gfgOtherbnd = gfg.Other(bnd=CF( (1,0,0,0) ))
    #gauged_gfU_CF = IfPos(gfor*n, transform_link(gfg, gfU, gfgOtherbnd), transform_link(gfgOtherbnd, gfU, gfg))
    
    gauged_gfU_CF = IfPos(gfor*n, transform_link(gfg, gfU, gfg.Other()), transform_link(gfg.Other(), gfU, gfg))
    # TODO: the gauge transformation out of bounds should reflect periodic BC
    # right now there is "nothing" outside
    gfgOtherbnd = CF( (1,0,0,0) )
    gauged_gfU_CFbnd = IfPos(gfor*n, transform_link(gfg, gfU, gfgOtherbnd), transform_link(gfgOtherbnd, gfU, gfg))

    U = fesU.TrialFunction()
    Up = fesU.TestFunction()

    gauged_gfU = GridFunction(fesU)

    gfU_vec = gfU.vec.CreateVector()

    
    # TODO: gauge transformations not correctly performed at border

    M_U = BilinearForm(fesU)
    #M_U += InnerProduct(U,Up)*dx(skeleton=True)
    M_U += 0.5*InnerProduct(U,Up)*dx(element_boundary=True)
    #M_U += 0.5*InnerProduct(U,Up)*ds(element_boundary=True)
    #M_U += 0.5*InnerProduct(U,Up)*ds
    M_U.Assemble()

    #f_U = LinearForm(fesU)
    f_U = BilinearForm(fesU)
    f_U += InnerProduct(gauged_gfU_CF,Up)*dx(skeleton=True)
    f_U += 0.5*InnerProduct(gauged_gfU_CFbnd,Up)*ds(skeleton=True)
    #f_U.Assemble()

    #f_U.Apply(gauged_gfU.vec, gfU_vec)
    f_U.Apply(gfU.vec, gfU_vec)
    gauged_gfU.vec.data = M_U.mat.Inverse() * gfU_vec

    gfU.vec.data = gauged_gfU.vec


#def _gauge_rho(gfrho, gfg, mesh):
def gauge_rho(gfrho, gfg):
    
    gauged_gfrhoCF = rotate_color(gfrho, gfg)
    #Draw(gauged_gfrhoCF, mesh)
    #Draw(gfrho, mesh)
    #gfrho.Set(gauged_gfrhoCF, definedon=mesh)
    gfrho.Interpolate(gauged_gfrhoCF)
    #Draw(gfrho, mesh)


def draw_edge(enum, mesh):
    draw_edges([enum], mesh)


def draw_edges(enums, mesh):
    gfUviz = GridFunction(HCurl(mesh, order=1))
    for enum in enums:
        gfUviz.vec.data[enum] = 1
    #print("Setting link:")
    Draw(gfUviz, mesh)


def single_link(gfU, mesh, enum, qtheta, theta, phi):

    trivial_gauge(gfU)

    #gfUviz = GridFunction(HCurl(mesh, order=1))
    #gfUviz.vec.data[enum] = 1
    print("Setting link:")
    #Draw(gfUviz, mesh)
    draw_edge(enum, mesh)
    #return set_gfU_link(gfU, enum=enum, qtheta=qtheta, theta=theta, phi=phi)
    set_gfU_link(gfU, enum=enum, qtheta=qtheta, theta=theta, phi=phi)

    return gfU

# optional gauge transformation:

def trivial_gauge(gfg):
    gfg.components[0].vec[:] = 1.
    gfg.components[1].vec[:] = 0.
    gfg.components[2].vec[:] = 0.
    gfg.components[3].vec[:] = 0.

    return gfg

def single_el_gauge(gfg, elnum, qtheta, theta, phi):
    
    gfg.components[0].vec[:] = 1.
    gfg.components[1].vec[:] = 0.
    gfg.components[2].vec[:] = 0.
    gfg.components[3].vec[:] = 0.
    
    n = axis(theta, phi)
    #qtheta = 0.2*pi
    q = get_rotq(qtheta, n)
    #el_num = 0   
    
    for i in range(0,4):
        gfg.components[i].vec[elnum] = q[i]
        
    return gfg



def random_links(gfU, qthetamax=2*pi, thetamax=pi, phimax=2*pi):
    mesh = gfU.space.mesh
    qthetas = qthetamax*np.random.rand(mesh.ne)
    thetas = thetamax*np.random.rand(mesh.ne)
    phis = phimax*np.random.rand(mesh.ne)

    for enum in range(mesh.ne):
        #print(enum)
        qtheta = qthetas[enum]
        theta = thetas[enum]
        phi = phis[enum]
        set_gfU_link(gfU, enum=enum, qtheta=qtheta, theta=theta, phi=phi)


# calculate the upwind charge current flux through element interfaces
# and return a vector of length N_interfaces
def calc_upwind_colorflux(gfrho, cfwind, gfUglob, mesh, glob_or=True):
    # evaluation of the upwind flux
    
    n = specialcf.normal(mesh.dim)
    gfor = get_gfor(mesh)
    #gfc_up = IfPos(cfwind*n, gfrho, vec_from_q(qmulCF(qmulCF(qconjCF(gfUglob), q_from_vecCF(gfrho.Other())), gfUglob)) )
    # in case the wind flows INTO the current element, the charge from the OTHER element should be taken
    # gfUglob always points OUT of the current element
    # thats why the inverse gauge link should be used (gfUglob with forward=False)
    gfc_up = IfPos(cfwind*n, gfrho, ptransport_color(gfrho.Other(), gfUglob, forward=False))
    n_up = IfPos(gfor*n, n, n.Other())

    fesjflux = FacetFESpace(mesh, order=0)**3

    #jflux = LinearForm(fesjflux)
    jflux = BilinearForm(fesjflux)
    jfluxp = fesjflux.TestFunction()

    # TODO: direction in EOM_update needs to be accounted for
    # glob_or flips the flux such that it aligns with gfUs and gfAs orientation
    if glob_or == True:
        # IfPos is necessary to align flux orientation with that of gauge links
        #jflux += InnerProduct(gfc_up*InnerProduct(cfwind,gfor), jfluxp)*dx(skeleton=True)
        jflux += IfPos(gfor*n_up,1,-1.)*InnerProduct(gfc_up*InnerProduct(cfwind,n_up), jfluxp)*dx(skeleton=True)
    else:
        jflux += InnerProduct(gfc_up*InnerProduct(cfwind,n_up), jfluxp)*dx(skeleton=True)

    # gfj_up = OuterProduct(gfc_up,cfwind)
    # for c in range(3):
    #     jflux += InnerProduct(InnerProduct(gfj_up[c,:],n), jfluxp[c])*dx(skeleton=True)
    #     jflux += InnerProduct(InnerProduct(gfj_up[c,:],n), jfluxp[c])*ds(skeleton=True)

    #jflux.Assemble()


    gfjflux = GridFunction(fesjflux)

    gfjflux_vec = gfjflux.vec.CreateVector()

    jflux.Apply(gfjflux_vec, gfjflux_vec)

    gfjflux.vec.data = gfjflux_vec
    return gfjflux